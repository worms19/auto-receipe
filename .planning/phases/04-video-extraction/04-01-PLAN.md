---
phase: 04-video-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - app.json
  - modules/audio-extractor/expo-module.config.json
  - modules/audio-extractor/ios/AudioExtractorModule.swift
  - modules/audio-extractor/src/index.ts
  - lib/extraction/types.ts
  - lib/extraction/url-validator.ts
  - lib/extraction/download.ts
  - lib/extraction/audio.ts
  - lib/extraction/thumbnail.ts
  - lib/extraction/extract.ts
  - scripts/cobalt-server.sh
autonomous: true
user_setup:
  - service: docker
    why: "Cobalt runs as Docker container for Instagram video URL resolution"
    env_vars: []
    dashboard_config:
      - task: "Install Docker Desktop"
        location: "https://www.docker.com/products/docker-desktop/"

must_haves:
  truths:
    - "Instagram URL can be validated and shortcode extracted"
    - "Cobalt API resolves Instagram URL to direct video download URL"
    - "Video can be downloaded to cache directory"
    - "Audio track can be extracted from video as .m4a"
    - "Thumbnail image can be captured from video"
    - "Extraction pipeline orchestrates download, audio, thumbnail, and cleanup"
  artifacts:
    - path: "lib/extraction/url-validator.ts"
      provides: "Instagram URL validation and shortcode extraction"
      exports: ["isValidInstagramUrl", "extractShortcode"]
    - path: "lib/extraction/download.ts"
      provides: "Cobalt API client and video download"
      exports: ["resolveInstagramUrl", "downloadVideo"]
    - path: "lib/extraction/audio.ts"
      provides: "Wrapper around native audio extraction module"
      exports: ["extractAudioTrack"]
    - path: "lib/extraction/thumbnail.ts"
      provides: "Video thumbnail capture"
      exports: ["extractThumbnail"]
    - path: "lib/extraction/extract.ts"
      provides: "Complete extraction pipeline orchestrator"
      exports: ["extractFromInstagramUrl"]
    - path: "lib/extraction/types.ts"
      provides: "Extraction type definitions"
      exports: ["ExtractionResult", "CobaltResponse"]
    - path: "modules/audio-extractor/ios/AudioExtractorModule.swift"
      provides: "Native iOS audio extraction via AVAssetExportSession"
      contains: "AVAssetExportPresetAppleM4A"
    - path: "modules/audio-extractor/src/index.ts"
      provides: "TypeScript API for native audio extractor"
      exports: ["extractAudio"]
    - path: "scripts/cobalt-server.sh"
      provides: "Convenience script to start Cobalt Docker container"
      contains: "docker"
  key_links:
    - from: "lib/extraction/extract.ts"
      to: "lib/extraction/download.ts"
      via: "resolveInstagramUrl and downloadVideo imports"
      pattern: "import.*from.*./download"
    - from: "lib/extraction/extract.ts"
      to: "lib/extraction/audio.ts"
      via: "extractAudioTrack import"
      pattern: "import.*extractAudioTrack.*from.*./audio"
    - from: "lib/extraction/extract.ts"
      to: "lib/extraction/thumbnail.ts"
      via: "extractThumbnail import"
      pattern: "import.*extractThumbnail.*from.*./thumbnail"
    - from: "lib/extraction/audio.ts"
      to: "modules/audio-extractor/src/index.ts"
      via: "Native module import"
      pattern: "import.*from.*audio-extractor"
    - from: "lib/extraction/download.ts"
      to: "fetch"
      via: "Cobalt API POST request"
      pattern: "fetch.*COBALT"
---

<objective>
Create extraction service layer: dev client transition, native audio extraction module, Cobalt download client, thumbnail capture, URL validator, and orchestrator.

Purpose: Build all the extraction infrastructure needed to replace mock download/extract in the pipeline. This includes transitioning from Expo Go to dev client (required for the native Swift module), creating the native AVFoundation module for audio extraction, and building TypeScript services for each extraction step.

Output: Complete `lib/extraction/` module with all services, `modules/audio-extractor/` native module, and `scripts/cobalt-server.sh` convenience script.
</objective>

<execution_context>
@/Users/damienanselmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/damienanselmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-video-extraction/04-RESEARCH.md
@lib/pipeline/store.ts
@lib/pipeline/mock-api.ts
@lib/types.ts
@lib/api/whisper.ts
@lib/api/errors.ts
@app.json
@package.json
@scripts/whisper-server.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dev client transition and native audio extraction module</name>
  <files>
    - package.json
    - app.json
    - modules/audio-extractor/expo-module.config.json
    - modules/audio-extractor/ios/AudioExtractorModule.swift
    - modules/audio-extractor/src/index.ts
  </files>
  <action>
**Step 1: Install expo-dev-client and expo-video-thumbnails.**

```bash
npx expo install expo-video-thumbnails expo-dev-client
```

Use `--legacy-peer-deps` if npm peer conflicts arise (consistent with prior phases).

**Step 2: Create the local Expo native module for audio extraction.**

Run the module scaffolding command:
```bash
npx create-expo-module@latest --local modules/audio-extractor
```

If the interactive prompts cannot be automated, manually create the module structure:

Create `modules/audio-extractor/expo-module.config.json`:
```json
{
  "platforms": ["ios"],
  "ios": {
    "modules": ["AudioExtractorModule"]
  }
}
```

Create `modules/audio-extractor/src/index.ts`:
```typescript
import { requireNativeModule } from 'expo-modules-core';

const AudioExtractorModule = requireNativeModule('AudioExtractor');

export async function extractAudio(videoUri: string, outputUri: string): Promise<string> {
  return AudioExtractorModule.extractAudio(videoUri, outputUri);
}
```

Create `modules/audio-extractor/ios/AudioExtractorModule.swift`:
```swift
import ExpoModulesCore
import AVFoundation

public class AudioExtractorModule: Module {
  public func definition() -> ModuleDefinition {
    Name("AudioExtractor")

    AsyncFunction("extractAudio") { (videoUri: String, outputUri: String, promise: Promise) in
      guard let videoURL = URL(string: videoUri) else {
        promise.reject("INVALID_URL", "Invalid video URI: \(videoUri)")
        return
      }

      guard let outputURL = URL(string: outputUri) else {
        promise.reject("INVALID_URL", "Invalid output URI: \(outputUri)")
        return
      }

      let asset = AVAsset(url: videoURL)

      guard let exportSession = AVAssetExportSession(
        asset: asset,
        presetName: AVAssetExportPresetAppleM4A
      ) else {
        promise.reject("EXPORT_FAILED", "Cannot create audio export session")
        return
      }

      exportSession.outputFileType = .m4a
      exportSession.outputURL = outputURL

      exportSession.exportAsynchronously {
        switch exportSession.status {
        case .completed:
          promise.resolve(outputURL.absoluteString)
        case .failed:
          promise.reject(
            "EXPORT_FAILED",
            exportSession.error?.localizedDescription ?? "Audio extraction failed"
          )
        case .cancelled:
          promise.reject("EXPORT_CANCELLED", "Audio extraction was cancelled")
        default:
          promise.reject(
            "EXPORT_FAILED",
            "Audio extraction failed with status: \(exportSession.status.rawValue)"
          )
        }
      }
    }
  }
}
```

**Step 3: Run expo prebuild to generate the ios/ directory.**

```bash
npx expo prebuild --platform ios
```

This generates the native Xcode project. The audio-extractor module will be auto-linked.

**Step 4: Verify the dev client builds.**

```bash
npx expo run:ios --simulator
```

Verify the app launches in the iOS Simulator. This confirms the dev client transition works and existing packages (nativewind, expo-sqlite, etc.) are compatible.

**Important notes:**
- Xcode must be installed for prebuild/run:ios.
- The app will no longer work with Expo Go after this transition. Always use `npx expo run:ios` going forward.
- If prebuild generates Podfile issues, run `cd ios && pod install` manually.
  </action>
  <verify>
- `modules/audio-extractor/` directory exists with expo-module.config.json, ios/AudioExtractorModule.swift, src/index.ts
- `ios/` directory exists (from prebuild)
- `npx expo run:ios --simulator` builds and launches successfully (or at minimum `npx expo export --platform ios` passes)
- expo-dev-client and expo-video-thumbnails appear in package.json dependencies
  </verify>
  <done>
Dev client transition complete. Native audio extraction module created with AVAssetExportSession. App builds and runs in iOS Simulator via dev client.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create extraction services and Cobalt setup script</name>
  <files>
    - lib/extraction/types.ts
    - lib/extraction/url-validator.ts
    - lib/extraction/download.ts
    - lib/extraction/audio.ts
    - lib/extraction/thumbnail.ts
    - lib/extraction/extract.ts
    - scripts/cobalt-server.sh
  </files>
  <action>
**Create `lib/extraction/types.ts`** with extraction type definitions:

```typescript
export interface ExtractionResult {
  audioUri: string;       // Cache URI to extracted .m4a audio
  thumbnailUri: string;   // Document directory URI to thumbnail image
}

export interface CobaltResponse {
  status: 'tunnel' | 'redirect' | 'picker' | 'error';
  url?: string;
  filename?: string;
  error?: { code: string; context?: Record<string, unknown> };
  picker?: Array<{ type: string; url: string; thumb?: string }>;
}
```

**Create `lib/extraction/url-validator.ts`** with Instagram URL validation:

```typescript
// Handles: /p/ABC123/, /reel/ABC123/, /reels/ABC123/, /tv/ABC123/
// With or without www, with or without username prefix
const INSTAGRAM_URL_REGEX = /^https?:\/\/(?:www\.)?instagram\.com\/(?:[^/]+\/)?(?:p|reel|reels|tv)\/([A-Za-z0-9_-]+)/;

export function isValidInstagramUrl(url: string): boolean {
  return INSTAGRAM_URL_REGEX.test(url.trim());
}

export function extractShortcode(url: string): string | null {
  const match = url.trim().match(INSTAGRAM_URL_REGEX);
  return match ? match[1] : null;
}
```

**Create `lib/extraction/download.ts`** with Cobalt API client and video download:

```typescript
import {
  downloadAsync,
  cacheDirectory,
  makeDirectoryAsync,
  getInfoAsync,
} from 'expo-file-system/legacy';
import { CobaltResponse } from './types';

const COBALT_API = 'http://127.0.0.1:9000';
const VIDEO_CACHE_DIR = `${cacheDirectory}wechef-videos/`;

export async function resolveInstagramUrl(instagramUrl: string): Promise<string> {
  const response = await fetch(`${COBALT_API}/`, {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      url: instagramUrl,
      videoQuality: '720',
    }),
  });

  if (!response.ok) {
    throw new Error(`Cobalt server error (${response.status}). Is Cobalt running? Start with: ./scripts/cobalt-server.sh`);
  }

  const data: CobaltResponse = await response.json();

  if (data.status === 'error') {
    const code = data.error?.code ?? 'unknown';
    throw new Error(`Could not download video: ${code}`);
  }

  if (data.status === 'tunnel' || data.status === 'redirect') {
    if (!data.url) throw new Error('Cobalt returned no video URL');
    return data.url;
  }

  if (data.status === 'picker' && data.picker?.length) {
    const video = data.picker.find(item => item.type === 'video');
    if (video) return video.url;
    // If no video in picker, try first item
    if (data.picker[0]?.url) return data.picker[0].url;
  }

  throw new Error('Could not resolve video URL from Instagram');
}

export async function downloadVideo(directUrl: string): Promise<string> {
  const dirInfo = await getInfoAsync(VIDEO_CACHE_DIR);
  if (!dirInfo.exists) {
    await makeDirectoryAsync(VIDEO_CACHE_DIR, { intermediates: true });
  }

  const filename = `video-${Date.now()}.mp4`;
  const fileUri = `${VIDEO_CACHE_DIR}${filename}`;

  const result = await downloadAsync(directUrl, fileUri);

  if (result.status !== 200) {
    throw new Error(`Video download failed with status ${result.status}`);
  }

  return result.uri;
}
```

**Create `lib/extraction/audio.ts`** wrapping the native module:

```typescript
import {
  cacheDirectory,
  makeDirectoryAsync,
  getInfoAsync,
} from 'expo-file-system/legacy';
import { extractAudio } from '../../modules/audio-extractor/src';

const AUDIO_CACHE_DIR = `${cacheDirectory}wechef-audio/`;

export async function extractAudioTrack(videoUri: string): Promise<string> {
  const dirInfo = await getInfoAsync(AUDIO_CACHE_DIR);
  if (!dirInfo.exists) {
    await makeDirectoryAsync(AUDIO_CACHE_DIR, { intermediates: true });
  }

  const filename = `audio-${Date.now()}.m4a`;
  const outputUri = `${AUDIO_CACHE_DIR}${filename}`;

  return extractAudio(videoUri, outputUri);
}
```

**Create `lib/extraction/thumbnail.ts`** using expo-video-thumbnails:

```typescript
import * as VideoThumbnails from 'expo-video-thumbnails';
import {
  documentDirectory,
  makeDirectoryAsync,
  getInfoAsync,
  copyAsync,
} from 'expo-file-system/legacy';

const THUMBNAIL_DIR = `${documentDirectory}thumbnails/`;

export async function extractThumbnail(videoUri: string): Promise<string> {
  const dirInfo = await getInfoAsync(THUMBNAIL_DIR);
  if (!dirInfo.exists) {
    await makeDirectoryAsync(THUMBNAIL_DIR, { intermediates: true });
  }

  // Capture frame at 1 second into the video
  const { uri: cacheUri } = await VideoThumbnails.getThumbnailAsync(videoUri, {
    time: 1000,
    quality: 0.7,
  });

  // Move thumbnail from cache to persistent storage
  const filename = `thumb-${Date.now()}.jpg`;
  const persistentUri = `${THUMBNAIL_DIR}${filename}`;
  await copyAsync({ from: cacheUri, to: persistentUri });

  return persistentUri;
}
```

**Create `lib/extraction/extract.ts`** -- the orchestrator that ties everything together:

```typescript
import { deleteAsync } from 'expo-file-system/legacy';
import { ExtractionResult } from './types';
import { isValidInstagramUrl } from './url-validator';
import { resolveInstagramUrl, downloadVideo } from './download';
import { extractAudioTrack } from './audio';
import { extractThumbnail } from './thumbnail';

export async function extractFromInstagramUrl(
  instagramUrl: string
): Promise<ExtractionResult> {
  if (!isValidInstagramUrl(instagramUrl)) {
    throw new Error(
      'Invalid Instagram URL. Please share a link to an Instagram reel or post.'
    );
  }

  // Step 1: Resolve Instagram URL to direct video URL via Cobalt
  const directUrl = await resolveInstagramUrl(instagramUrl);

  // Step 2: Download video to cache
  const videoUri = await downloadVideo(directUrl);

  try {
    // Step 3: Extract audio track (native AVFoundation module)
    const audioUri = await extractAudioTrack(videoUri);

    // Step 4: Capture thumbnail (before deleting video)
    const thumbnailUri = await extractThumbnail(videoUri);

    return { audioUri, thumbnailUri };
  } finally {
    // Always clean up the video file -- never persist videos
    try {
      await deleteAsync(videoUri, { idempotent: true });
    } catch {
      // Best-effort cleanup -- don't fail the pipeline over cleanup
    }
  }
}
```

**Create `scripts/cobalt-server.sh`** -- convenience script modeled after whisper-server.sh:

```bash
#!/usr/bin/env bash
# Start self-hosted Cobalt server for WeChef development.
# Prerequisites: Docker Desktop installed and running
#
# Cobalt resolves Instagram URLs to direct video download links.
# API runs on http://127.0.0.1:9000
#
# Usage:
#   ./scripts/cobalt-server.sh          # Start Cobalt
#   ./scripts/cobalt-server.sh stop     # Stop Cobalt
#   ./scripts/cobalt-server.sh status   # Check if running

set -euo pipefail

COBALT_PORT="${COBALT_PORT:-9000}"

# Check Docker is available
if ! command -v docker &> /dev/null; then
  echo "Error: Docker not found. Install Docker Desktop from:"
  echo "  https://www.docker.com/products/docker-desktop/"
  exit 1
fi

# Check Docker daemon is running
if ! docker info &> /dev/null 2>&1; then
  echo "Error: Docker daemon is not running. Start Docker Desktop first."
  exit 1
fi

CONTAINER_NAME="wechef-cobalt"

case "${1:-start}" in
  stop)
    echo "Stopping Cobalt..."
    docker stop "$CONTAINER_NAME" 2>/dev/null && echo "Stopped." || echo "Not running."
    docker rm "$CONTAINER_NAME" 2>/dev/null || true
    ;;
  status)
    if docker ps --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
      echo "Cobalt is running on http://127.0.0.1:${COBALT_PORT}"
    else
      echo "Cobalt is not running."
    fi
    ;;
  start|"")
    # Stop existing container if any
    docker stop "$CONTAINER_NAME" 2>/dev/null || true
    docker rm "$CONTAINER_NAME" 2>/dev/null || true

    echo "Starting Cobalt on port ${COBALT_PORT}..."
    docker run -d \
      --name "$CONTAINER_NAME" \
      --restart unless-stopped \
      -p "127.0.0.1:${COBALT_PORT}:9000/tcp" \
      -e "API_URL=http://127.0.0.1:${COBALT_PORT}/" \
      ghcr.io/imputnet/cobalt:10

    echo ""
    echo "Cobalt is running at http://127.0.0.1:${COBALT_PORT}"
    echo "Test with:"
    echo "  curl -s http://127.0.0.1:${COBALT_PORT}/ -H 'Content-Type: application/json' -d '{\"url\":\"https://www.instagram.com/reel/EXAMPLE\"}'"
    ;;
  *)
    echo "Usage: $0 [start|stop|status]"
    exit 1
    ;;
esac
```

Make the script executable:
```bash
chmod +x scripts/cobalt-server.sh
```
  </action>
  <verify>
- All 7 files exist in `lib/extraction/`: types.ts, url-validator.ts, download.ts, audio.ts, thumbnail.ts, extract.ts
- `scripts/cobalt-server.sh` exists and is executable
- `npx tsc --noEmit` passes (no TypeScript/import errors)
- `lib/extraction/extract.ts` imports from all other extraction modules
- `lib/extraction/audio.ts` imports from `../../modules/audio-extractor/src`
- `lib/extraction/download.ts` uses `expo-file-system/legacy` imports
- `lib/extraction/thumbnail.ts` imports `expo-video-thumbnails`
  </verify>
  <done>
All extraction services created: URL validator, Cobalt download client, audio extraction wrapper, thumbnail capture, and orchestrating extract function. Cobalt setup script ready. Video file cleanup via try/finally in orchestrator.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Dev client builds: `npx expo run:ios --simulator` launches the app
2. Native module exists: `modules/audio-extractor/` with Swift and TypeScript files
3. Extraction services exist: `lib/extraction/` with 6 TypeScript files
4. Cobalt script exists: `scripts/cobalt-server.sh` is executable
5. No TypeScript errors: `npx tsc --noEmit`
6. expo-dev-client and expo-video-thumbnails in package.json
</verification>

<success_criteria>
- App runs via dev client (`npx expo run:ios`) instead of Expo Go
- Native audio extractor module compiles as part of the iOS build
- All extraction service files exist with correct exports
- Cobalt convenience script works (`./scripts/cobalt-server.sh status`)
- No TypeScript errors, app builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/04-video-extraction/04-01-SUMMARY.md`
</output>
