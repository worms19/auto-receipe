---
phase: 03-api-integrations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/api/errors.ts
  - lib/api/config.ts
  - lib/api/whisper.ts
  - .env.example
  - package.json
autonomous: true
user_setup:
  - service: openai
    why: "Audio transcription via Whisper API"
    env_vars:
      - name: EXPO_PUBLIC_OPENAI_API_KEY
        source: "OpenAI Dashboard -> API keys -> Create new secret key"

must_haves:
  truths:
    - "Whisper service can transcribe audio file to text"
    - "API errors are typed and retryable status is indicated"
    - "API keys can be retrieved from env vars or secure store"
  artifacts:
    - path: "lib/api/errors.ts"
      provides: "Typed API error classes"
      exports: ["APIError", "TranscriptionError", "StructuringError"]
    - path: "lib/api/config.ts"
      provides: "API key retrieval functions"
      exports: ["getOpenAIKey", "getAnthropicKey"]
    - path: "lib/api/whisper.ts"
      provides: "Whisper transcription service"
      exports: ["transcribeAudio"]
  key_links:
    - from: "lib/api/whisper.ts"
      to: "lib/api/errors.ts"
      via: "TranscriptionError import"
      pattern: "import.*TranscriptionError.*from.*errors"
    - from: "lib/api/whisper.ts"
      to: "expo-file-system"
      via: "FileSystem.uploadAsync"
      pattern: "FileSystem\\.uploadAsync"
---

<objective>
Create API service foundation with error types, configuration utilities, and Whisper transcription service.

Purpose: Establish the API layer infrastructure and implement real audio transcription using OpenAI's Whisper API. This replaces the mock transcription with actual speech-to-text capability.

Output: Working `lib/api/` module with config, errors, and Whisper service that can transcribe audio files.
</objective>

<execution_context>
@/Users/damienanselmi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/damienanselmi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-api-integrations/03-RESEARCH.md
@lib/pipeline/store.ts
@lib/pipeline/mock-api.ts
@lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create API foundation</name>
  <files>
    - package.json
    - lib/api/errors.ts
    - lib/api/config.ts
    - .env.example
  </files>
  <action>
Install required dependencies:
```bash
npx expo install expo-file-system expo-secure-store
npm install zod buffer --legacy-peer-deps
```

Note: @anthropic-ai/sdk will be installed in Plan 02 to avoid unused dependency if Plan 01 fails.

Create `lib/api/errors.ts` with typed error classes:
- `APIError` base class with `statusCode` and `retryable` properties
- `TranscriptionError` extends APIError, retryable on 429/503
- `StructuringError` extends APIError, retryable on 429/529

Create `lib/api/config.ts` with key retrieval:
- `getOpenAIKey()` - check SecureStore first, fallback to EXPO_PUBLIC_OPENAI_API_KEY
- `getAnthropicKey()` - check SecureStore first, fallback to EXPO_PUBLIC_ANTHROPIC_API_KEY
- `setOpenAIKey(key)` and `setAnthropicKey(key)` for future settings screen
- Throw descriptive errors if keys not configured

Create `.env.example` documenting required env vars:
```
# API Keys (for development only - use SecureStore in production)
EXPO_PUBLIC_OPENAI_API_KEY=sk-...
EXPO_PUBLIC_ANTHROPIC_API_KEY=sk-ant-...
```

Follow patterns from 03-RESEARCH.md code examples.
  </action>
  <verify>
- `npm run lint` passes (no import errors)
- `lib/api/errors.ts` exports APIError, TranscriptionError, StructuringError
- `lib/api/config.ts` exports getOpenAIKey, getAnthropicKey
- `.env.example` exists with documented variables
  </verify>
  <done>
API foundation files exist with typed errors and config utilities. Dependencies installed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Whisper transcription service</name>
  <files>
    - lib/api/whisper.ts
  </files>
  <action>
Create `lib/api/whisper.ts` implementing audio transcription:

```typescript
import * as FileSystem from 'expo-file-system';
import { TranscriptionError } from './errors';

const WHISPER_ENDPOINT = 'https://api.openai.com/v1/audio/transcriptions';

export interface TranscriptionOptions {
  language?: string; // ISO-639-1 code (e.g., 'en')
  prompt?: string;   // Context hint for better accuracy
}

export async function transcribeAudio(
  audioUri: string,
  apiKey: string,
  options: TranscriptionOptions = {}
): Promise<string>
```

Implementation details:
1. Use `FileSystem.uploadAsync` with MULTIPART upload type (required for Android)
2. Set `fieldName: 'file'` and `mimeType: 'audio/m4a'`
3. Include `model: 'whisper-1'` in parameters
4. Add optional language and prompt parameters if provided
5. Handle response status codes:
   - 200: Parse JSON and return `result.text`
   - 429: Throw TranscriptionError with retryable=true
   - 413: Throw "Audio file too large (max 25MB)"
   - Other: Throw with response body as message
6. Wrap unknown errors in TranscriptionError

Use the exact pattern from 03-RESEARCH.md "Whisper Transcription with Error Handling" code example.
  </action>
  <verify>
- `npm run lint` passes
- `lib/api/whisper.ts` exports `transcribeAudio` function
- Function signature matches: `(audioUri: string, apiKey: string, options?: TranscriptionOptions) => Promise<string>`
- Imports TranscriptionError from ./errors
- Uses FileSystem.uploadAsync (not fetch with FormData)
  </verify>
  <done>
Whisper transcription service ready. Function accepts audio URI and API key, returns transcript text, handles errors with typed TranscriptionError.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. All files exist in lib/api/: errors.ts, config.ts, whisper.ts
2. No TypeScript/lint errors: `npm run lint`
3. App still builds: `npx expo export --platform ios` (dry run)
4. Dependencies in package.json: expo-file-system, expo-secure-store, zod, buffer
</verification>

<success_criteria>
- lib/api/ directory created with errors.ts, config.ts, whisper.ts
- All exports match must_haves artifacts
- No lint errors
- App builds successfully
- .env.example documents required API keys
</success_criteria>

<output>
After completion, create `.planning/phases/03-api-integrations/03-01-SUMMARY.md`
</output>
